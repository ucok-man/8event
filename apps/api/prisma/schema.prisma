// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["views"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model PointBalance {
  id           String           @id @default(uuid())
  user         User             @relation(fields: [userId], references: [id])
  userId       String
  pointBalance Int // this can be negative or positive
  type         PointBalanceType
  startDate    DateTime         @default(now())
  endDate      DateTime // for substract type this should be null
}

model Coupon {
  id                 String @id @default(uuid())
  userId             String
  code               String @unique
  discountPercentage Int

  isUsed    Boolean  @default(false)
  startDate DateTime @default(now())
  endDate   DateTime

  event   Event  @relation(fields: [eventId], references: [id])
  eventId String

  user User @relation(fields: [userId], references: [id])

  transactions Transaction[]
}

model User {
  id             String   @id @default(uuid())
  name           String
  email          String   @unique
  password       String
  profilePicture String?
  role           Role
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  referralCode String  @unique // A special code that this user gets. They can share it with others to invite them to sign up.
  referrals    User[]  @relation("SignupReferral") // A list of users who signed up using this user's referral code.
  referredBy   User?   @relation("SignupReferral", fields: [referredById], references: [id]) // The user who invited this user to sign up (if they used a referral code).
  referredById String? // The ID of the user who invited this user (if a referral code was used).

  pointBalances   PointBalance[]
  organizedEvents Event[]        @relation("UserOrganizedEvents")
  transactions    Transaction[]
  reviews         Review[]
  coupons         Coupon[]
}

model Event {
  id          String   @id @default(uuid())
  name        String
  description String
  eventImage  String
  startDate   DateTime
  endDate     DateTime
  // totalCapacity Int // Should be managed on Event View
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  location  String
  latitude  Float
  longitude Float

  organizer   User   @relation("UserOrganizedEvents", fields: [organizerId], references: [id])
  organizerId String

  categories EventCategory[]
  tickets    Ticket[]

  transactions Transaction[]
  reviews      Review[]
  coupons      Coupon[]
}

model EventCategory {
  id   String @id @default(uuid())
  name String @unique

  events Event[]
}

model Ticket {
  id             String   @id @default(uuid())
  type           String
  price          Float
  isFree         Boolean // check constraint (if true 'price' should be 0) on migration
  seatsAvailable Int // this will be used to calculate total seat available for an event
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  event   Event  @relation(fields: [eventId], references: [id])
  eventId String

  transactions Transaction[]
}

model Transaction {
  id             String            @id @default(uuid())
  status         TransactionStatus
  ticketQuantity Int
  totalPrice     Float
  paymentProof   String?
  createdAt      DateTime          @default(now())
  expiredAt      DateTime

  event   Event  @relation(fields: [eventId], references: [id])
  eventId String

  buyer   User   @relation(fields: [buyerId], references: [id])
  buyerId String

  ticket   Ticket @relation(fields: [ticketId], references: [id])
  ticketId String

  usedPoints Int     @default(0)
  coupon     Coupon? @relation(fields: [couponId], references: [id])
  couponId   String?
}

model Review {
  id        String   @id @default(uuid())
  rating    Int      @default(0) // check constraint to max of 5 on migration // value 0 mean user dont give rating;
  comment   String
  createdAt DateTime @default(now())

  event   Event  @relation(fields: [eventId], references: [id])
  eventId String

  customer   User   @relation(fields: [customerId], references: [id]) // user who review the event
  customerId String
}

enum TransactionStatus {
  WAITING_PAYMENT
  WAITING_CONFIRMATION
  COMPLETED
  CANCELLED
}

enum Role {
  CUSTOMER
  ORGANIZER
}

enum PointBalanceType {
  ADD
  SUBSTRACT
}

// create manual view on migration. Dont update this manually on app
view RecordOrganizerAverageRating {
  organizerId   String @unique // this will be user id with role Organizer only
  averageRating Float // calculated from average all review rating for the event ever created for this organizer
}

// create manual view on migration. Dont update this manually on app
view RecordEventTotalSeat {
  eventId   String @unique // this will be event id
  totalSeat Int // calculated from ticket.seatsAvailable
}

view RecordUserPointBalance {
  userId       String @unique
  pointBalance Int // active point balance
}
